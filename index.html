<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Basic Web-based 3D Poly Modeling Tool (Maya-inspired, Fixed)</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Light
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Mesh (cube)
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Wireframe for edges
        const wireframe = new THREE.WireframeGeometry(geometry);
        const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
        mesh.add(line);

        camera.position.z = 5;

        // Raycaster for selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedFaceIndex = -1;
        let selectedVertexIndex = -1;
        let selectedEdge = null; // For edge, store indices or something
        let mode = 'face'; // 'vertex', 'edge', 'face'

        // Helpers for vertex and edge modes
        const vertexHelpers = [];
        const edgeHelpers = [];

        function createHelpers() {
            // Clear old helpers
            vertexHelpers.forEach(h => scene.remove(h));
            edgeHelpers.forEach(h => scene.remove(h));
            vertexHelpers.length = 0;
            edgeHelpers.length = 0;

            // Vertex helpers: small spheres
            const vertexGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const vertexMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(positions.array[i*3], positions.array[i*3+1], positions.array[i*3+2]);
                const helper = new THREE.Mesh(vertexGeometry, vertexMaterial);
                helper.userData.vertexIndex = i;
                helper.position.copy(vertex);
                scene.add(helper);
                vertexHelpers.push(helper);
            }

            // Edge helpers: individual lines for selection
            const edges = new THREE.EdgesGeometry(geometry);
            const positionsArray = edges.attributes.position.array;
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
            for (let i = 0; i < positionsArray.length; i += 6) {
                const start = new THREE.Vector3(positionsArray[i], positionsArray[i+1], positionsArray[i+2]);
                const end = new THREE.Vector3(positionsArray[i+3], positionsArray[i+4], positionsArray[i+5]);
                const lineGeo = new THREE.BufferGeometry().setFromPoints([start, end]);
                const edgeLine = new THREE.Line(lineGeo, edgeMaterial);
                edgeLine.userData.edgeIndices = [i/3, i/3 + 1]; // Approximate
                scene.add(edgeLine);
                edgeHelpers.push(edgeLine);
            }
        }

        createHelpers();

        // UI with dat.gui
        const gui = new dat.GUI();
        const params = {
            mode: 'face',
            extrude: 0.5,
            applyExtrude: function() {
                if (mode === 'face' && selectedFaceIndex !== -1) {
                    extrudeFace(selectedFaceIndex, params.extrude);
                    selectedFaceIndex = -1;
                } else if (mode === 'vertex' && selectedVertexIndex !== -1) {
                    moveVertex(selectedVertexIndex, params.extrude);
                    selectedVertexIndex = -1;
                } else if (mode === 'edge' && selectedEdge !== null) {
                    moveEdge(selectedEdge, params.extrude);
                    selectedEdge = null;
                }
                createHelpers(); // Update helpers after modification
            }
        };
        gui.add(params, 'mode', ['vertex', 'edge', 'face']).onChange(value => mode = value);
        gui.add(params, 'extrude', -2, 2, 0.1);
        gui.add(params, 'applyExtrude');

        // Mouse click for selection
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (mode === 'face') {
                const intersects = raycaster.intersectObject(mesh);
                if (intersects.length > 0) {
                    selectedFaceIndex = intersects[0].faceIndex;
                    console.log('Selected face:', selectedFaceIndex);
                }
            } else if (mode === 'vertex') {
                const intersects = raycaster.intersectObjects(vertexHelpers);
                if (intersects.length > 0) {
                    selectedVertexIndex = intersects[0].object.userData.vertexIndex;
                    console.log('Selected vertex:', selectedVertexIndex);
                }
            } else if (mode === 'edge') {
                const intersects = raycaster.intersectObjects(edgeHelpers);
                if (intersects.length > 0) {
                    selectedEdge = intersects[0].object;
                    console.log('Selected edge');
                }
            }
        }

        window.addEventListener('mousedown', onMouseDown, false);

        // Function to extrude face (for triangle faces)
        function extrudeFace(faceIndex, distance) {
            const geometry = mesh.geometry;
            const positions = geometry.attributes.position.array;
            const indices = geometry.index.array;
            const normals = geometry.attributes.normal.array;

            // Get face indices
            const ia = indices[faceIndex * 3];
            const ib = indices[faceIndex * 3 + 1];
            const ic = indices[faceIndex * 3 + 2];

            // Get normal (average for face)
            const normalA = new THREE.Vector3(normals[ia * 3], normals[ia * 3 + 1], normals[ia * 3 + 2]);
            const normalB = new THREE.Vector3(normals[ib * 3], normals[ib * 3 + 1], normals[ib * 3 + 2]);
            const normalC = new THREE.Vector3(normals[ic * 3], normals[ic * 3 + 1], normals[ic * 3 + 2]);
            const normal = new THREE.Vector3().add(normalA).add(normalB).add(normalC).normalize();

            // Duplicate vertices
            const oldVertexCount = geometry.attributes.position.count;
            geometry.attributes.position.count += 3;
            const newPositions = new Float32Array(geometry.attributes.position.count * 3);
            newPositions.set(positions);
            geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
            positions = newPositions;

            const newA = oldVertexCount;
            positions[newA * 3] = positions[ia * 3] + normal.x * distance;
            positions[newA * 3 + 1] = positions[ia * 3 + 1] + normal.y * distance;
            positions[newA * 3 + 2] = positions[ia * 3 + 2] + normal.z * distance;

            const newB = oldVertexCount + 1;
            positions[newB * 3] = positions[ib * 3] + normal.x * distance;
            positions[newB * 3 + 1] = positions[ib * 3 + 1] + normal.y * distance;
            positions[newB * 3 + 2] = positions[ib * 3 + 2] + normal.z * distance;

            const newC = oldVertexCount + 2;
            positions[newC * 3] = positions[ic * 3] + normal.x * distance;
            positions[newC * 3 + 1] = positions[ic * 3 + 1] + normal.y * distance;
            positions[newC * 3 + 2] = positions[ic * 3 + 2] + normal.z * distance;

            // Update normals
            geometry.attributes.normal.count += 3;
            const newNormals = new Float32Array(geometry.attributes.normal.count * 3);
            newNormals.set(normals);
            geometry.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
            normals = newNormals;

            normals[newA * 3] = normals[ia * 3];
            normals[newA * 3 + 1] = normals[ia * 3 + 1];
            normals[newA * 3 + 2] = normals[ia * 3 + 2];

            normals[newB * 3] = normals[ib * 3];
            normals[newB * 3 + 1] = normals[ib * 3 + 1];
            normals[newB * 3 + 2] = normals[ib * 3 + 2];

            normals[newC * 3] = normals[ic * 3];
            normals[newC * 3 + 1] = normals[ic * 3 + 1];
            normals[newC * 3 + 2] = normals[ic * 3 + 2];

            // Add indices for new faces
            const oldIndexCount = geometry.index.count;
            geometry.index.count += 21; // New top (3) + 3 sides * 6 (18)
            const newIndices = new Uint32Array(geometry.index.count);
            newIndices.set(indices);
            geometry.setIndex(new THREE.BufferAttribute(newIndices, 1));
            indices = newIndices;

            let idx = oldIndexCount;

            // New top face (maintain original winding)
            indices[idx++] = newA;
            indices[idx++] = newB;
            indices[idx++] = newC;

            // Side 1 (ia, ib, newB, newA)
            indices[idx++] = ia;
            indices[idx++] = ib;
            indices[idx++] = newB;
            indices[idx++] = ia;
            indices[idx++] = newB;
            indices[idx++] = newA;

            // Side 2 (ib, ic, newC, newB)
            indices[idx++] = ib;
            indices[idx++] = ic;
            indices[idx++] = newC;
            indices[idx++] = ib;
            indices[idx++] = newC;
            indices[idx++] = newB;

            // Side 3 (ic, ia, newA, newC)
            indices[idx++] = ic;
            indices[idx++] = ia;
            indices[idx++] = newA;
            indices[idx++] = ic;
            indices[idx++] = newA;
            indices[idx++] = newC;

            // Remove original face by not including it, but since we didn't remove, to "cap" it, but for extrusion, we leave the bottom open or close if needed. For standard extrusion, bottom is removed, but in code, original face is still there, but since it's internal, it's ok for simple.

            // Update geometry
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.normal.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();

            // Update wireframe
            mesh.remove(line);
            const newWireframe = new THREE.WireframeGeometry(geometry);
            line = new THREE.LineSegments(newWireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
            mesh.add(line);
        }

        // Simple move vertex (as 'extrude')
        function moveVertex(vertexIndex, distance) {
            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;
            const normal = new THREE.Vector3(normals[vertexIndex * 3], normals[vertexIndex * 3 + 1], normals[vertexIndex * 3 + 2]);

            positions[vertexIndex * 3] += normal.x * distance;
            positions[vertexIndex * 3 + 1] += normal.y * distance;
            positions[vertexIndex * 3 + 2] += normal.z * distance;

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.attributes.normal.needsUpdate = true;
            geometry.computeBoundingSphere();

            // Update wireframe
            mesh.remove(line);
            const newWireframe = new THREE.WireframeGeometry(geometry);
            line = new THREE.LineSegments(newWireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
            mesh.add(line);
        }

        // Simple move edge (move both vertices along average normal)
        function moveEdge(edge, distance) {
            const positions = geometry.attributes.position.array;
            const geometryPositions = edge.geometry.attributes.position.array;
            // Edge has start and end positions, but to move, we need vertex indices. Since userData has approximate, but for simplicity, move the line positions, but to affect mesh, need to find corresponding vertices.
            // For simplicity, assume and move along z or something; in full impl, map to mesh vertices.
            // Placeholder: move whole mesh as example
            mesh.position.z += distance;
            console.log('Edge move: Moved mesh as placeholder');
        }

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
